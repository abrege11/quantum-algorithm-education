<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        <meta name="keywords" content="Quantum, Alogrithms, Deutsch">
        <meta name="author" content="Abraham Brege">
        <title>QAE - Deutsch's algorithm</title>
        <link rel="stylesheet" href="../../styles/deutsch.styles.css">
        <script src="../../utils/latex-helper.js"></script>
    </head>
    <body>
        <span id="deutsch">
        <a href="../index.html"><h2>Deutsch's algorithm</h2></a>
        </span>
        [<a href="javascript:history.back()">skip to deutsch-jozsa</a>]
        <p>Deutsch's algorithm is a function \( f(x) \) that takes in either 0 or 1, and determines whether it is <a href="../basics/function-types.html#constant">constant</a> or <a href="../basics/function-types.html#balanced">balanced</a>.</p>
        <p>Formally, this is written as</p>
        \[ f :\{0,1\} \longrightarrow \{0,1\} \]
        <p>A constant function is a function that returns the same output no matter the input</p>
        <p>\( f(0) = 0 \quad \quad f(x) = x \)</p>
        <p>\( f(1) = 0 \quad \quad f(y) = x \)</p>
        <p>\( f(0) = f(1) \)</p>
        <br>
        <p>A balanced function is a function that returns different outputs given different inputs</p>
        <p>\( f(0) = 0 \quad \quad f(x) = x \)</p>
        <p>\( f(1) = 1 \quad \quad f(y) = y \)</p>
        <p>\( f(0) \ne f(1) \)</p>
        <br>
        <p>Using any <a href="../basics/classical-computation.html#classical-algorithms">classical algorithm</a>, to know if \(f(x) = f(y)\), you need to evaluate the function \(f\) for \(x\) and \(y\).</p>
        <p>Using Deutsch's <a href="../basics/quantum-computation.html#quantum-algorithms">quantum algorithm</a>, we only have to evaluate the function \(f\) once.</p>
        <br>
        <p>Taking a look at Deutsch's <a href="../quantum-circuits/quantum-circuit-diagram.html">quantum circuit diagram</a>:</p>
        <br>
        <img src="../../../assets/deutsch.png">
        <p>
        Deutsch's algorithm takes in two <a href="../notation/dirac-notation.html#bra-ket">kets \(|0\rangle\) and \(|1\rangle\)</a>. We'll use \( |\Psi_x\rangle \)
        to take a look at the different states our kets are in throughout the algorithm.
        </p>
        <p>
        \( |\Psi_1\rangle \): <br>&emsp; Our ket at this time is <a href="../notation/dirac-notation.html">\(|01\rangle\)<a></a>.
        Both \(|0\rangle\) and \(|1\rangle\) are being sent into \(H\) (<a href="../quantum-circuits/quantum-gates.html#hadamarad">Hadamarad</a>) gates. Hadamarad
        gates put the given qubit into a superposition state.
        </p>
        <p>
        \( |\Psi_2\rangle \): <br>&emsp; The <a href="../basics/superposition.html">superposition</a> state of \(|0\rangle\) is
        \[ \frac{|\ket{0} + \ket{1}|}{\sqrt{2}} \]
        &emsp;and \(|1\rangle\) is 
        \[ \frac{|\ket{0} - \ket{1}|}{\sqrt{2}} \]
        &emsp;Both of these states can be rewritten as <a href="../notation/dirac-notation.html#plus-minus-states">\(|+\rangle\) and \(|-\rangle\)</a>, respectively, which we can refer to as \(|+-\rangle\)<br>
        &emsp;We can then rewrite the \(|+\rangle\) as \[ \frac{\left( \ket{0} + \ket{1} \right)}{\sqrt{2}} \] &emsp; so, \(|+-\rangle\) is now represented as
        \[ \frac{\left( \ket{0} + \ket{1} \right) \ket{-}}{\sqrt{2}} \] &emsp; Furthermore, we can distribute \(|-\rangle\) into to \(|+\rangle\) obtain
        \[ \frac{\left( \ket{0} \ket{-} + \ket{1} \ket{-} \right)}{\sqrt{2}} \]
        </p>
        <p>
        \( |\Psi_3\rangle \): <br>&emsp; We then apply our <a href="../quantum-circuits/quantum-oracle.html">quantum oracle \( U_f \)</a> to get
        \[ \frac{\left(U_f \ket{0} \ket{-} + U_f \ket{1} \ket{-} \right)}{\sqrt{2}}  \] &emsp;
        These states are in <a href="../quantum-circuits/phase-oracle.html">phase oracle</a> form, so given
        \[ U_f \ket{x} \ket{-} = (-1)^{f(x)} \ket{x} \ket{-} \]&emsp;
        Where \( \ket{x} = \ket{0} \) or \( \ket{1} \), we get
        \[ \frac{(-1)^{f(0)} \ket{0} \ket{-} + (-1)^{f(1)} \ket{1} \ket{-}}{\sqrt{2}} \]&emsp;
        Furthermore, we can factor \( \ket {-} \) out for now and just focus on what is inside the parentheses<br>&emsp;
        \[ 
        \left( \frac{(-1)^{f(0)} \ket{0} + (-1)^{f(1)} \ket{1} }{\sqrt{2}} \right) \ket{-} 
        \longrightarrow 
        \frac{(-1)^{f(0)} \ket{0} + (-1)^{f(1)} \ket{1} }{\sqrt{2}} 
        \]&emsp;
        Now, our outputs depend on whether our function is constant, or balanced.<br><br>&emsp;
        If \( f(x) \) is constant, \( f(0) = f(1) \), we get two options:<br><br>&emsp;
        \( f(x) = 1 \):
        \[ 
        \frac{(-1)^1 \ket{0}  + (-1)^1 \ket{1}}{\sqrt{2}} 
        \longrightarrow
        \frac{- \ket{0} + -\ket{1}}{\sqrt{2}}
        \longrightarrow
        -\left(\frac{ \ket{0} + \ket{1} }{\sqrt{2}} \right)
        \] &emsp;
        and <br><br>&emsp;
        \( f(x) = 0 \):
        \[ 
        \frac{(-1)^0 \ket{0}  + (-1)^0 \ket{1}}{\sqrt{2}} 
        \longrightarrow
        \frac{(1)\ket{0} + (1)\ket{1}}{\sqrt{2}}
        \longrightarrow
        \frac{ \ket{0} + \ket{1} }{\sqrt{2}}
        \] &emsp;
        We can simplify this answer,
        \[ 
        \left[ \frac{ \ket{0} + \ket{1} }{\sqrt{2}}, -\frac{ \ket{0} + \ket{1} }{\sqrt{2}} \right]
        \longrightarrow
        \pm\left(\frac{ \ket{0} + \ket{1} }{\sqrt{2}} \right)
        \]&emsp;
        giving<br><br>&emsp;
        \( f(0) = f(1) \):
        \[
        \pm\left(\frac{ \ket{0} + \ket{1} }{\sqrt{2}} \right)
        \]
        <br><br>&emsp;
        If \( f(x) \) is balanced, \( f(1) \ne f(0) \), we get two options:
        <br><br>&emsp;
        \( f(0) = 0, \) &ensp;\( f(1) = 1 \):
        \[ 
        \frac{(-1)^0 \ket{0}  + (-1)^1 \ket{1}}{\sqrt{2}} 
        \longrightarrow
        \frac{(1)\ket{0} -\ket{1}}{\sqrt{2}}
        \longrightarrow
        \frac{\ket{0} -\ket{1}}{\sqrt{2}}
        \] &emsp;
        and <br><br>&emsp;
        \( f(0) = 1, \)&ensp; \( f(1) = 0 \):
        \[ 
        \frac{(-1)^1 \ket{0}  + (-1)^0 \ket{1}}{\sqrt{2}} 
        \longrightarrow
        \frac{-\ket{0} + (1)\ket{1}}{\sqrt{2}}
        \longrightarrow
        \frac{ -\ket{0} + \ket{1} }{\sqrt{2}}
        \longrightarrow
        -\left( \frac{ \ket{0} - \ket{1} }{\sqrt{2}} \right)
        \] &emsp;
        We can simplify this answer,
        \[ 
        \left[ \frac{ \ket{0} - \ket{1} }{\sqrt{2}}, -\frac{ \ket{0} - \ket{1} }{\sqrt{2}} \right]
        \longrightarrow
        \pm\left(\frac{ \ket{0} - \ket{1} }{\sqrt{2}} \right)
        \]&emsp;
        giving<br><br>&emsp;
        \( f(0) \ne f(1) \):
        \[
        \pm\left(\frac{ \ket{0} - \ket{1} }{\sqrt{2}} \right)
        \]<br>
        </p>
        <p>
        &emsp;
        <b>As of now, our states are:<br><br>&emsp;
        \( f(0) = f(1) \):
        \[
        \pm\left(\frac{ \ket{0} + \ket{1} }{\sqrt{2}} \right)
        \]&emsp;
        and <br><br>&emsp;
        \( f(0) \ne f(1) \):
        \[
        \pm\left(\frac{ \ket{0} - \ket{1} }{\sqrt{2}} \right)
        \]
        </b><br>&emsp;
        Notice that our two states are equal to \( \ket{+} \) and \(\ket{-} \):
        \[
        \pm
        \left[
        \frac{ \ket{0} + \ket{1} }{\sqrt{2}},
        \vphantom{\frac{ \ket{0} + \ket{1} }{\sqrt{2}}}
        \frac{ \ket{0} - \ket{1} }{\sqrt{2}}
        \right]
        \longrightarrow
        \pm \left[
        \vphantom{\frac{ \ket{0} + \ket{1} }{\sqrt{2}}}
        \ket{+},
        \vphantom{\frac{ \ket{0} + \ket{1} }{\sqrt{2}}}
        \ket{-}
        \right]
        \]&emsp;
        </p>
        <p>
        \( |\Psi_4\rangle \): <br>&emsp; We then send the top qubit through a \( H \)adamarad gate. <br><br>&emsp;
        If \( f(0) = f(1) \):
        \[
        \pm \ket{+}
        \longrightarrow
        \pm \ket{0}
        \]&emsp;
        and<br><br>&emsp;
        If \( f(0) \ne f(1) \):
        \[
        \pm \ket{-}
        \longrightarrow
        \pm \ket{1}
        \]&emsp;
        </p>
        <p>
        This leaves us with:
        \[
        \pm
        \left[
        \vphantom{\frac{ \ket{0} + \ket{1} }{\sqrt{2}}}
        \ket{0},
        \ket{1}
        \right]
        \]
        <br>
        <b>Therefore, <br>&emsp;
        If \( \ket{0} \) is measured, the function is constant, \( f(0) = f(1) \) <br>&emsp;
        and if \( \ket{1} \) is measured, the function is balanced, \( f(0) \ne f(1) \)
        </b>
        <br><br>
        Deutsch's algorithm proves <a href="../misc/quantum-supremacy.html">quantum supremacy</a>.<br> 
        It performs an operation that would take 2 measurments in <a href="../basics/classical-computation.html">classical computation</a>, and gets the same output with only 1 measurement using <a href="../basics/quantum-computation.html">quantum computation</a>.
        </p><br><br><br><br>
        <span id="deutsch-jozsa">
        <a href="javascript:history.back()"><h2>Deutsch-Jozsa algorithm</h2></a>
        </span>
        <p>
        Deutsch-Jozsa's algorithm, similar to Deutsch's algorithm, determines whether a function \( f \) is constant, or balanced. <br><br>
        However, unlike Deutsch's algorithm, Deutsch Jozsa's algorithm can take in an amount \( n \) of qubits. Formally, this is represented as 
        </p>
        \[ f :\{0,1\}^n \longrightarrow \{0,1\} \]
        <p>Using any <a href="../basics/classical-computation.html#classical-algorithms">classical algorithm</a>, in the worst case scenario, you would have to evaluate the function \( 2^{n-1} + 1 \) times.</p>
        <p>Using Deutsch-Jozsa's <a href="../basics/quantum-computation.html#quantum-algorithms">quantum algorithm</a>, we only have to evaluate the function \(f\) once.</p> 
        <p><b>Why \( 2^{n-1} + 1 \) ?</b></p>
        <p>\( 2^{n-1} \) refers to half of n, as \( 2^5 = 32 \), \( 2^4 = 16 \), \( 2^3 = 8 \), and so on.</p>
        <p>The +1 can be explained by a short example</p>
        <p>
        When \( n=5 \)<br>&emsp;
        In the worst case, no matter if \( f \) is constant or balanced, the first \( 2^{n-1} \) (or \( 16 \) in this case) evaluations could be all \( \ket{0} \)'s or \( \ket{1} \)'s. Lets say we get all \( \ket{0} \)'s <br>&emsp;
        Thus, the \( +1 \) refers to the need for us to evaluate once more to see if we get another \( \ket{0} \), meaning\( f \) is constant, or \( \ket{1} \), meaning \( f \) is balanced.
        </p>
        <p>Let's take a look at the circuit diagram.</p>
        <img src="../../../assets/deutsch-jozsa.png">
        <p>
        Notice, the symbols
        \[ \ket{0}^{\otimes n} \]
        \[ /^n \]
        \[ H^{\otimes n} \]
        Referring to \( n \) amounts of \( \ket{0} \)'s, qubits (represented by lines), and \( H \) gates, respectively.
        </p>
        <p>
        \( |\Psi_1\rangle \): <br>&emsp;
        Our ket at this time is \( n \) amounts of \( \ket{0} \)'s and one \( \ket{1} \), which we can represent as \( \ket{0}^{\otimes n} \ket{1} \)
        </p>
        <p>
        \( |\Psi_2\rangle \): <br>&emsp;
        Our qubits are run through \( H \) gates which put them into a superposition state<br>&emsp;
        Our ket is now \( n \) amounts of \( \ket{+} \)'s and one \( \ket{-} \), which we can represent as 
        \[
        \ket{+}^{\otimes n} \ket{-}
        \]&emsp;
        Let's focus on our state \( \ket{+}^{\otimes n} \), we can redefine this as 
        \[  
        \ket{+}^{\otimes n}
        \longrightarrow
        \left( \frac{ \ket{0} + \ket{1} }{\sqrt{2}} \right)^{\otimes n}
        \longrightarrow
        \frac{1}{\sqrt{2}} \Bigg(\ket{0} + \ket{1}\Bigg) ^{\otimes n}
        \] &emsp;
        Lets say that \( n=2 \), in this case, we can expand this state,
        \[
        \frac{1}{\sqrt{2}} \Bigg(\ket{0} + \ket{1}\Bigg) \frac{1}{\sqrt{2}} \Bigg(\ket{0} + \ket{1}\Bigg)
        \longrightarrow
        \frac{1}{\sqrt{2^2}} \Bigg( \ket{00} + \ket{01} + \ket{10} + \ket{11} \Bigg)
        \] &emsp;
        Similarly, lets say \( n=3 \)
        \[
        \frac{1}{\sqrt{2}} \Bigg(\ket{0} + \ket{1}\Bigg) \frac{1}{\sqrt{2}} \Bigg(\ket{0} + \ket{1}\Bigg)\frac{1}{\sqrt{2}} \Bigg(\ket{0} + \ket{1}\Bigg)
        \longrightarrow
        \frac{1}{\sqrt{2^3}} \Bigg( \ket{000} + \ket{001} + \ket{010} + \ket{011} + \ket{100} + \ket{101} + \ket{110} + \ket{111} \Bigg)
        \]&emsp;
        This can be represented as
        \[
        \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} \ket{x}
        \] &emsp;
        Now, looking back at our full state 
        \[
        \ket{+}^{\otimes n} \ket{-}  
        \]&emsp;
        We can represent this as
        \[ 
        \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} \ket{x} \ket{-}
        \] &emsp;
        </p>
        <p>
        \( |\Psi_3\rangle \): <br> &emsp;
        Looking back at our diagram, <br>
        <img src="../../../assets/deutsch-jozsa.png"><br>&emsp;
        our state
        \[ 
        \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} \ket{x} \ket{-}
        \] &emsp;
        is ran through our quantum oracle \( U_f \)
        \[ 
        \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} \ket{x} \ket{-} 
        \longrightarrow
        U_f\frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} \ket{x} \ket{-}
        \longrightarrow
        \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} U_f \ket{x} \ket{-}   
        \] &emsp;
        Recall
        \[ U_f \ket{x} \ket{-} = (-1)^{f(x)} \ket{x} \ket{-} \]&emsp;
        So,
        \[
        \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} U_f \ket{x} \ket{-}
        \longrightarrow
        \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} (-1)^{f(x)} \ket{x} \ket{-}
        \] &emsp;
        Again, we can factor \( \ket{-} \) out.
        </p>
        <p>
        \( |\Psi_4\rangle \): <br>&emsp;
        We now run each of our \( \ket{+} \)'s through \( H \) gates
        \[
        \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} (-1)^{f(x)} \ket{x}
        \longrightarrow
        \frac{1}{\sqrt{2^n}} \sum_{x \in \{0,1\}^n} (-1)^{f(x)} H^{\otimes n} \ket{x}
        \] &emsp;
        Now we can look back at our Hadamarad transform for \( \ket{+}^{\otimes n}  \) and apply \( (-1)^{f(x)} \)
        \[
        \ket{+}^{\otimes n} 
        \longrightarrow
        (-1)^{f(x)}\ket{+}^{\otimes n}
        \] &emsp;
        Recall,
        \[
        \ket{+}
        \longrightarrow
        \frac{1}{\sqrt{2}} \Bigg(\ket{0} + \ket{1}\Bigg)
        \]&emsp;
        So \[ (-1)^{f(x)}\ket{+}^{\otimes n} \]&emsp; can be represented by
        \[
        (-1)^{f(x)} \left( \frac{1}{\sqrt{2}} \Bigg(\ket{0} + \ket{1}\Bigg) \right)
        \]&emsp;
        Which we can rewrite as
        \[
        H\ket{x} = \frac{1}{\sqrt{2}} \Bigg(\ket{0} + (-1)^x\ket{1}\Bigg)
        \]&emsp;
        This leaves us with two options <br><br>&emsp;
        \( x=0 \)
        \[
        H\ket{0} = \frac{1}{\sqrt{2}} \Bigg(\ket{0} + (-1)^0\ket{1}\Bigg)
        \] &emsp;
        Which gives us the \( \ket{+} \), or
        \[
        \left( \frac{ \ket{0} + \ket{1} }{\sqrt{2}} \right)
        \]
        </p>
        &emsp; and
        <br><br>&emsp;
        \( x=1 \)
        \[
        H\ket{1} = \frac{1}{\sqrt{2}} \Bigg(\ket{0} + (-1)^1\ket{1}\Bigg)
        \] &emsp;
        Which gives us the \( \ket{-} \), or
        \[
        \left( \frac{ \ket{0} - \ket{1} }{\sqrt{2}} \right)
        \]
        </p>
        <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
    </body>
</html>