<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="author" content="Abraham Brege">
        <title>QAE - Basics</title>
        <link rel="stylesheet" href="../../styles/basics.styles.css">
        <script src="../../utils/latex-helper.js"></script>
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </head>
    <body>
        <a href="javascript:history.back()"><h2>Basics</h2></a>
        <p>Don't know a thing about quantum computing? No worries. Follow the roadmap below to prepare yourself for the quantum algorithms ahead.</p>
        <h3>Roadmap</h3>
        <p>Before proceeding, remember that all of the material covered below is specific to the algorithms covered to allow you to quickly grasp these complex topics. To obtain a deeper understanding of these topics, it is heavily recommended to study from accredited material.</p>
        <p>If you're familiar with a topic, skip to your level of understanding</p>
        <p>
        <a href="#classical-computation">Classical Computation</a>
        \( \rightarrow \)
        <a href="#classical-logic-gates">Classical Logic Gates</a>
        \( \rightarrow \)
        <a href="#function-types">Function Types</a>
        \( \rightarrow \)
        <a href="#mathematics">Mathematics</a>
        \( \rightarrow \)
        <a href="#notation">Notation</a>
        \( \rightarrow \)
        <a href="#quantum-computation">Quantum Computation</a>
        \( \rightarrow \)
        <a href="#bits-and-qubits">Bits and Qubits</a>
        \( \rightarrow \)
        <a href="#superposition">Superposition</a>
        \( \rightarrow \)
        <a href="#entanglement">Entanglement</a>
        \( \rightarrow \)
        <a href="#quantum-logic-gates">Quantum Gates</a>
        \( \rightarrow \)
        <a href="#quantum-circuit-basics">Quantum Circuits</a>
        </p>
        <span id="classical-computation"><br>
        <h3>Classical Computation</h3>
        <p>
        Classical computing is a very broad topic with countless branches and subsets of the practice. We'll focus on the basics and move on. <br><br>
        Classical computers use bits <br>
        Bits are binary values <br>
        Binary values are either 0 or 1 <br> <br>
        These bits are run through logic gates to perform operations on them. These few elementary operations are the building blocks of all technology today. <br><br>
        In all, this is a gross over-generalization of the practice. However, this is really all you need to know for our application.
        </p> <br>
        </span>
        <span id="classical-logic-gates">
        <h3>Classical Logic Gates</h3>
        <p>
        The gates we will cover are AND, OR, NOT, XOR, and NAND
        <table>
            <tr>
            <th>Gate</th>
            <th>Circuit</th>
            <th>Truth Table</th>
            </tr>
            <tr>
            <td>AND</td>
            <td><img src="../../../assets/and.png"></td>
            <td><img src="../../../assets/and-truth.png"></td>
            </tr>
            <tr>
            <td>OR</td>
            <td><img src="../../../assets/or.png"></td>
            <td><img src="../../../assets/or-truth.png"></td>
            </tr>
            <tr>
            <td>NOT</td>
            <td><img src="../../../assets/not.png"></td>
            <td><img src="../../../assets/not-truth.png"></td>
            </tr>
            <tr>
            <td>XOR</td>
            <td><img src="../../../assets/xor.png"></td>
            <td><img src="../../../assets/xor-truth.png"></td>
            </tr>
            <tr>
            <td>NAND</td>
            <td><img src="../../../assets/nand.png"></td>
            <td><img src="../../../assets/nand-truth.png"></td>
            </tr>
          </table>
        </p>
        <p>
        Looking at the truth tables, lets dissect each gate. <br><br>
        <b>AND - </b> Outputs 1 when A & B are 1<br><br>
        <b>OR - </b> Outputs 1 when A or B is 1, along with A & B being 1<br><br>
        <b>NOT - </b> Outputs the opposite of A<br><br>
        <b>XOR - </b> Same as the OR gate, but excludes when A & B is 1<br><br>
        <b>NAND - </b> Stands for N(OT)AND. The opposite of AND's logic.<br><br>
        </p>
        <p>
        The key takeaway is the concept of a <b>universal</b> gate.<br><br>
        <b>NAND</b> is a universal gate, in layman's terms, any other logic gate can be made of just <b>NAND</b> gates. <br><br>
        For more information on gate-universality, visit <a href="https://www.allaboutcircuits.com/textbook/digital/chpt-3/gate-universality/">here</a>
        </p>
        </span>
        <span id="function-types">
        <h3>Function Types</h3>
        On this site, you will hear the term "constant" and "balanced" function.
        <p>A constant function is a function that returns the same output no matter the input</p>
        <p>\( f(0) = 0 \quad \quad f(x) = x \)</p>
        <p>\( f(1) = 0 \quad \quad f(y) = x \)</p>
        or
        <p>\( f(0) = 1 \quad \quad f(x) = y \)</p>
        <p>\( f(1) = 1 \quad \quad f(y) = y \)</p>
        so
        <p>\( f(0) = f(1) \)</p>
        <br>
        <p>A balanced function is a function that returns different outputs given different inputs</p>
        <p>\( f(0) = 0 \quad \quad f(x) = x \)</p>
        <p>\( f(1) = 1 \quad \quad f(y) = y \)</p>
        or
        <p>\( f(0) = 1 \quad \quad f(x) = y \)</p>
        <p>\( f(1) = 0 \quad \quad f(y) = x \)</p>
        so
        <p>\( f(0) \ne f(1) \)</p>
        Another note for balanced functions, outputs are equal in quantity. <br>
        If you get five 1's, you will also get five 0's. 
        </span>
        <span id="mathematics">
        <h3>Mathematics</h3>
        While the mathematics in quantum computation looks complicated, it's all quite elementary when you look closer.
        </span>
        <span id="notation">
        <h3>Notation</h3>
        The largest takeaway from notation will be <b>Dirac notation</b>.<br><br>
        Dirac notation, also known as bra-ket notation is a way to represent vectors. <br><br>
        \[
        \braket{bra|ket}
        \]
        Bra's \( \langle\Psi_b| \) represent row vectors, while Ket's \( |\Psi_k\rangle \) represent column vectors.<br>
        \[
        \langle\Psi_b| = 
        \begin{pmatrix}
        y_1 & y_2 & y_3
        \end{pmatrix}  
        \]
        \[
        |\Psi_k\rangle = 
        \begin{pmatrix}
        x_1 \\
        x_2 \\
        x_3
        \end{pmatrix}   
        \]
        The *'s represent that we need to take the complex conjugate when converting from a row to column vector. <br><br>
        To give you an idea of how these Bra-ket's work, let us look at these two vectors
        \[
        |\Psi_1\rangle = 
        \begin{pmatrix}
        a \\
        b \\
        c
        \end{pmatrix}  
        \quad
        and
        \quad
        |\Psi_2\rangle = 
        \begin{pmatrix}
        x \\
        y \\
        z
        \end{pmatrix}  
        \]
        So, if we want to find \( \langle\Psi_1| \Psi_2 \rangle \), remember that \( \langle\Psi_1| \) and \( |\Psi_2\rangle \) are equal to 
        \[
        \langle\Psi_1|= 
        a^* 
        \begin{pmatrix}
        1 &
        0 &
        0
        \end{pmatrix} 
        + 
        b^*
        \begin{pmatrix}
        0 &
        1 &
        0
        \end{pmatrix}
        +
        c^*
        \begin{pmatrix}
        0 &
        0 &
        1
        \end{pmatrix}
        \]
        and
        \[
        |\Psi_2\rangle = 
        x 
        \begin{pmatrix}
        1 \\
        0 \\
        0
        \end{pmatrix}  
        + y 
        \begin{pmatrix}
        0 \\
        1 \\
        0
        \end{pmatrix}
        + z 
        \begin{pmatrix}
        0 \\
        0 \\
        1
        \end{pmatrix}
        \] <br><br>
        If we were to represent these vectors as \( \langle\Psi_1| \Psi_2 \rangle \), you would get
        \[
        \langle\Psi_1| \Psi_2 \rangle = xa^* + yb^* + xc^* = 1
        \]
        It is important to note that those values add up to a probability. So, their sum is always equal to 1. <br><br>
        Before we continue, lets take a look at some common examples of dirac notation you'll see frequently<br><br>
        \( 
        \ket{0} =          
        \begin{pmatrix}
        1 \\
        0
        \end{pmatrix} 
        \) <br><br>
        \( 
        \ket{1} =  
        \begin{pmatrix}
        0 \\
        1
        \end{pmatrix} 
        \) <br><br>
        This will be the most common example you see. <br><br>
        Working with \( \ket{0} \) and \( \ket{1} \), you can remember which vectors these represent as thinking of the number inside of the ket as the position where the 1 is located in the vector.<br><br>
        That's a mouthful, but notice the 1 is in the "0" spot in \( \ket{0} \) and the "1" spot in \( \ket{1} \). <b>(remember this is zero-indexed, intuitive for computer scientists, but for others, counting starts with 0. So the "0" spot is the first spot in the vector)</b><br><br>
        Next,<br><br>
        \(
        \ket{+} =
        \frac{|\ket{0} + \ket{1}|}{\sqrt{2}}
        \)
        <br>
        \(
        \ket{-} =
        \frac{|\ket{0} - \ket{1}|}{\sqrt{2}}
        \)
        <br><br>
        These represent our superposition states of \( \ket{0} \) and \( \ket{1} \), we'll get to superposition later.<br><br>
        Now that you have an idea of our standard dirac notation states, let's take a look at an example where we express a vector in dirac notation <br><br>
        Given the vector
        \[
        |\Psi_1\rangle = 
        \begin{pmatrix}
        a \\
        b
        \end{pmatrix} 
        =
        a 
        \begin{pmatrix}
        1 \\
        0
        \end{pmatrix} 
        +
        b
        \begin{pmatrix}
        0 \\
        1
        \end{pmatrix} 
        \]
        Notice that our vectors can be represented as \( \ket{0} \) and \( \ket{1} \)
        \[
        |\Psi_1\rangle = 
        \begin{pmatrix}
        a \\
        b
        \end{pmatrix} 
        =
        a \ket{0}
        +
        b \ket{1}
        \]
        </span>
        <span id="quantum-computation">
        <h3>Quantum Computation</h3>
        Quantum computing spans much further than Computer Science. It largely based in physics and mathematics, which both utilize quantum mechanics. <br><br>
        We are going to focus on quantum algorithms, we won't touch much on the physics side of quantum computation. But it is important to cover some fundamental components<br><br>
        Below we can see some key concepts that are used in quantum computation that we will cover throughout our algorithms.
        </span>
        <span id="bits-and-qubits">
        <h3>Bits and Qubits</h3>
        As we've covered, bits are a binary representation of data, you have the options 0 and 1. <br><br>
        Qubits are one in the same regrading binary. They too have the states 0 and 1, however, they also have a superposition state.
        </span>
        <span id="superposition">
        <h3>Superposition</h3>
        Superposition is the backbone of every quantum algorithm. <br><br>
        This a term that describes how a system can be in a state of all of it's possible outcomes. <br><br>
        Looking at the superposition of a qubit, most likely you've seen
        \[
        \frac{1}{\sqrt{2}} \ket{0} +
        \frac{1}{\sqrt{2}} \ket{1} 
        \]
        This for example, states that our bit is in a superposition state where it is a 50/50 chance it will be measured as a 0 or 1. <br><br>
        It is important to note that whatever system is in a superposition state, that state is lost upon measurement. To which you obtain either 0 or 1 at the given probabilities of the kets.
        </span>
        <span id="entanglement">
        <h3>Entanglement</h3>
        It is easiest to understand entanglement by a quick example. <br><br>
        This explanation is derived from <a href="https://www.youtube.com/watch?v=rqmIVeheTVU">this</a> video <br><br>
        If you were to give two people coins and have them flip them, they would have no connection, person A flipping heads would have no effect on person B flipping tails.
        However, if you were to entangle these coins, person A flipping heads would let you know person B flipped tails <b>immediately</b>. <br><br>
        The important part here is that it would happen immediately. Even if they were on other sides of the universe, they would know instantly. <br><br>
        Although I pride myself on making sure everything on this website is mine, whether that be an interpretation, or an asset. Another amazing resource on entanglement is from my favorite theoretical physicist, Sabine Hossenfelder, who has an amazing video on this topic. <br><br>
        Check out her explanation <a href="https://www.youtube.com/watch?v=j6Mw3_tOcNI&list=PLwgQsqtH9H5djIfFhXE6We207beTgUnyL&index=10">here</a> (skip to 3:30)
        </span>
        <span id="quantum-logic-gates">
        <h3>Quantum Gates</h3>
        
        </span>
        <span id="quantum-circuit-basics">
        <h3>Quantum Circuits</h3>

        </span>
        </body>
</html>